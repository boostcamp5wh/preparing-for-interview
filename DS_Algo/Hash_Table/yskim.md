# 해쉬란?
어떤 입력값을 임의의 길이를 갖는 출력값으로 매핑하는 것. 이를 행하는 것이 해쉬함수고 입력값에 대해 고유한 값을 지니는 특성탓에 암호화나 데이터구조에 쓰인다.

암호화에서는 해쉬함수의 특성인 단방향성 때문에 해쉬를 탈취당한것으로는 암호를 복호할 수 없기에 쓰이거나 (암호 대신 salt 와 함께 hash를 저장) 변조감지(md5)같은곳에서 쓰이고 

데이터 구조에서는 키-값 매핑을 통해 키를 색인으로 쓰고 색인에 해시값을 써서 빠르게 찾는 용도로 사용한다.

# 충돌 해결 방안은?

임의의 길이로 고정을 해놓고 쓰기 때문에 중복되는 경우가 있다. 크게 두 가지 해결방안이 있는데

1. 빈 주소에 넣기(open addressing) 
2. 같은 주소에서 linked list 로 넣기(seperate chaining)

  1번의 경우 다시 3개로 나뉘는데
  
  1. 선형탐색(Linear Probing)(충돌되면 빈 곳 나올 때 까지 다음 버킷에 넣기)
  2. 제곱탐색(Quadratic Probing)(충돌되면 빈 곳 나올 때 까지 충돌위치의 n^2 다음의 버킷에 넣기)
  3. 이중해시(Double Hashing)(충돌된 버킷값을 다시 입력으로 넣어서 출력된 값을 버킷으로)



장단점이 있다.

open addressing 의 경우 추가 메모리공간도 필요없고, 포인터도 필요없고, 오버헤드도 적다
linked list 는 구현이 쉽다.



# 리사이징

open addressing은 꽉차면 자리가 없으니까 필수고 seperate chaining 은 그 자체로 메모리를 더 쓰니까 상관없다고 생각하겠지만 linked list 로 구조가 바뀌므로 속도도 linked list 이므로 늘리는게 낫다.

보통 해시 버킷 개수가 75% 정도 차면 더 큰 용량의 새 array 를 만들고 hash 를 새로 계산해서 옮겨준다.

# 속도

array 와 달리 삽입, 삭제, 검색 모두 O(1) 이다. index로 일일이 찾을필요가 없이 바로 매핑되니까.

대신 그 만큼 공간 복잡도는 커진다. python 3 의 경우 dict 가 순서를 지니지만 기본적으로는 순서와는 상관없는 자료구조이기 때문에 순서있는 배열에는 문제가 생길 수 있다.
